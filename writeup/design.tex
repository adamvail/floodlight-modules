\section{Design}
\label{sec:design}

We have extended the Floodlight OpenFlow controller to ensure two conflicting OpenFlow rules can not be present on a switch at the same time.
Since Floodlight has a global view of the network it can make informed decisions concerning which rules an application is allowed to install on a switch and which rules should be disalowed.
Much of our work for Floodlight was inspired by FortNOX \cite{Porras:2012:SEK:2342441.2342466}.
FortNOX created a security enforcement kernel for the NOX OpenFlow controller \cite{Gude:2008:NTO:1384609.1384625} which did similar things to what we have created in Floodlight.
Unfortunately, NOX is no longer under development and FortNOX was never released to the public.
The need for functionality similar to FortNOX in a widely supported controller motivated us to extend Floodlight.
We also discovered several shortcomings of FortNOX which we adressed in our Floodlight implementation.

\subsection{Alias Reduced Rules}
\label{subsec:arr}
In order to detect rule conflicts, we borrowed the idea presented in FortNOX of representing OpenFlow messages as \emph{alias reduced rules} (ARR).
An ARR is simply an expansion of a rule's match headers along with its actions.
This allows the controller to see the full effect the rule will have on flows moving through the switch, effectively incorporating both the input (the match) and the output (the effect of the actions) of a given rule.
Our Floodlight module then compares candidate-rule ARRs and outgoing packets against a table of these ARRs stored in our application to determine if there is a conflict between an active rule in the switch's flow table and a candidate rule that an application is attempting to install.
If no conflict is found then the candidate rule is allowed to be written to the switch.
To illustrate a malicious rule that would be targeted by our application, we present a simple example of what FortNOX calls ``dynamic-flow tunneling.'' Effectively, if one imagines a simple firewall implemented by a rule dropping all packets matching a given flow, a malicious application could insert a rule remapping that flow around the firewall rule, effectively circumventing it. 

The firewall application installs a static flow rule upon switch connection that states:

\begin{align}
\begin{aligned}
\label{eq:staticfirewall}
(h1) \rightarrow (h8:80) \Rightarrow Action: drop 
\end{aligned}
\end{align}

\begin{align}
\begin{aligned}
\label{eq:staticfirewall}
(h1) \rightarrow (h8:80) \Rightarrow Action: drop 
\end{aligned}
\end{align}

In the attack, the subversive application dynamically installs a flow rule that will effectively allow traffic from \texttt{h1} to be delivered to \texttt{h8} by remapping the destination of packets being sent from \texttt{h1} to some dummy host \texttt{h7} to instead be delivered to the destination of \texttt{h2:80}. Clearly, \texttt{h1} can effectively communicate with \texttt{h8} by sending its packets to \texttt{h7} instead.

\begin{equation}\label{eq:subversive}
(h1) \rightarrow (h7:80) \Rightarrow Action: set (dst = h8), (port = 80)
\end{equation}

\begin{align}
\begin{aligned}
\label{eq:subversive}
&(h1) \rightarrow (h7:80) \Rightarrow  \\
    &\qquad Action: set (dst = h8), (port = 80) 
\end{aligned}
\end{align}

\begin{align}
\begin{aligned}
\label{eq:subversive}
&(h1) \rightarrow (h7:80) \Rightarrow  \\
    &\qquad Action: set (dst = h8), (port = 80) 
\end{aligned}
\end{align}

The ARR for rule \ref{eq:staticfirewall} looks the same as the rule itself, combining its match with its actions.
The ARR for rule \ref{eq:subversive} expands the rule into:

\begin{equation}\label{eq:arrsubversive}
(h1) \rightarrow \{(h7:80) (h8:80)\} \Rightarrow Action: forward
\end{equation}

The ARR for rule \ref{eq:staticfirewall} looks essentially the same as the rule itself.
The ARR for rule \ref{eq:subversive} expands the rule into:

\begin{align}
\begin{aligned}
\{(h1)\} \rightarrow \{(h7:80),&(h8:80)\} \Rightarrow \\ 
     &\qquad Action: forward \nonumber
\end{aligned}
\end{align}

\subsection{Detecting Conflict}
\label{subsec:conflict}
Floodlight maintains a per switch set of ARRs that correspond to active rules in the switch's flow table.
When an application attempts to add a rule to the switch's flow table, Floodlight creates an ARR for the candidate rule (cARR) and does a pairwise check of the candidate ARR with every ARR representing active rules in the switch's flow table (fARR). A table of rules currently in the switch is maintained in our Floodlight module. Rule timeouts are registered by using the OpenFlow callback functionality, which registers an event with the controller upon timeout. %[TODO: elaborate]
The conflict detection algorithm works as follows:
\begin{enumerate}
\item If the cARR and fARR have the same actions, then allow the candidate.
\item If the cARR and fARR have any intersection in their source sets, then take the union of the two source sets.
\item If the cARR and fARR have any intersection in their destination sets, then take the union of the two destination sets.
\item If both unions result in non-empty sets, then there is a conflict. Otherwise, allow the candidate rule and add cARR to the switch's set of active ARRs.
\end{enumerate} 

As an example, consider the ARRs we created above where the static firewall rule is currently in the switch (fARR) and the subversive application's remapping rule is the candidate (cARR):

\begin{enumerate}
\item The two ARRs have different actions. \mbox{fARR = drop} and \mbox{cARR = forward}. Therefore we need to check the source and destination sets of the two ARRs.
\item The two source sets intersect, therefore we take the union of the sets:
\begin{align}
\begin{aligned}
\{(h1)\} \cup \{(h1)\} = (h1) \nonumber
\end{aligned}
\end{align}
\item The destination sets intersect (h8:80), therefore we take the union of the sets:
\begin{align}
\begin{aligned}
\{(h8:80)\} \cup \{(h7:80),&(h8:80)\} = \\
        & \qquad \{(h7:80),(h8:80)\} \nonumber
\end{aligned}
\end{align}
\end{enumerate} 

This leaves the two sets non-empty, and Floodlight sees that these two rules are in conflict.
In the case where a rule has wildcarded fields, the union includes the "widest" possible rule.
For example, if the static firewall rule wanted to drop all traffic to \texttt{h8} regardless of destination port then the union of the destination sets would be:
\begin{align}
\begin{aligned}
\{(h8)\} \cup \{(h7:80),(h8:80)\} =  \{(h7:80),(h8)\} \nonumber
\end{aligned}
\end{align}

This still yields a non-empty set for both the source and destination sets and therefore is correctly identified as a conflict and disallowed.


