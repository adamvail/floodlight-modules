\section{Design}
\label{sec:design}

We have extended the Floodlight OpenFlow controller to ensure two conflicting OpenFlow rules can not be present on a switch at the same time.
Since Floodlight has a global view of the network it can make informed decisions concerned which rules an application is allowed to install on a switch and which rules should be disalowed.
Much of our work for Floodlight was inspired by FortNOX \cite{Porras:2012:SEK:2342441.2342466}.
FortNOX created a security enforcement kernel for the NOX OpenFlow controller \cite{Gude:2008:NTO:1384609.1384625} which did similar things to what we have created in Floodlight.
Unfortunately, NOX is no longer under development and FortNOX was never released to the public.
The need for functionality similar to FortNOX in a widely supported controller drove us extend Floodlight.
We also discovered several shortcomings of FortNOX which we adressed in our Floodlight implementation.

\subsection{Alias Reduced Rules}
\label{subsec:arr}
In order to detect rule conflicts, we borrowed the idea presented in FortNOX of representing OpenFlow messages as \emph{alias reduced rules} (ARR).
An ARR is simply an expansion of a rule's match headers along with its actions.
This allows the controller to see the full effect the rule will have on flows moving through the switch, effectively incorporating both the input (the match) and the output (the effect of the actions) of a given rule.
Our Floodlight module then compares candidate-rule ARRs and outgoing packets against a table of these ARRs stored in our application to determine if there is a conflict between an active rule in the switch's flow table and a candidate rule that an application is attempting to install.
If no conflict is found then the candidate rule is allowed to be written to the switch.
To illustrate a malicious rule that would be targeted by our application, we present a simple example of what FortNOX calls ``dynamic-flow tunneling.'' Effectively, if one imagines a simple firewall implemented by a rule dropping all packets matching a given flow, a malicious application could insert a rule remapping that flow around the firewall rule, effectively circumventing it. 

The firewall application installs a static flow rule upon switch connection that states:

\begin{equation}\label{eq:staticfirewall}
(h1) \rightarrow (h8:80) \Rightarrow Action: drop
\end{equation}

In the attack, the subversive application dynamically installs a flow rule to remap the destination and port number of \texttt{h1}'s packets to \texttt{h7} on port \texttt{80}:

\begin{equation}\label{eq:subversive}
(h1) \rightarrow (h7:80) \Rightarrow Action: set (dst = h8) and (port = 80)
\end{equation}

The ARR for rule \ref{eq:staticfirewall} looks essentially the same as the rule itself.
The ARR for rule \ref{eq:subversive} expands the rule into:

\begin{equation}\label{eq:arrsubversive}
(h1) \rightarrow (h7:80) (h8:80) \Rightarrow Action: forward
\end{equation}

\subsection{Detecting Conflict}
\label{subsec:conflict}
Floodlight maintains a per switch set of ARRs that correspond to active rules in the switch's flow table.
When an application attempts to add a rule to the switch's flow table, Floodlight creates an ARR for the candidate rule (cARR) and does a pairwise check of the candidate ARR with every other ARR representing active rules in the switch's flow table (fARR).
The conflict detection algorithm works as follows:
\begin{enumerate}
\item If the cARR and fARR have the same actions, then allow the candidate.
\item If the cARR and fARR have any intersection in their source sets, then take the union of the two source sets.
\item If the cARR and fARR have any intersection in their destination sets, then take the union of the two destination sets.
\item If both unions result in non-empty sets, then there is a conflict. Otherwise, allow the candidate rule and add cARR to the switch's set of active ARRs.
\end{enumerate} 

As an example, consider the ARRs we created above where the static firewall rule is currently in the switch (fARR) and the subversive application's remapping rule is the candidate (cARR):

\begin{enumerate}
\item The two ARRs have different actions. fARR = drop and cARR = forward. Therefore we need to check the source and destination sets of the two ARRs.
\item The two source sets intersect, therefore we take the union of the sets:
\begin{equation} 
(h1) \bigcap (h1) \Rightarrow (h1) 
\end{equation}
\item The destination sets intersect (h8:80), therefore we take the union of the sets:
\begin{equation} 
(h8:80) \bigcap (h7:80) (h8:80)  \Rightarrow (h7:80) (h8:80) 
\end{equation}
\end{enumerate} 

This leaves the two sets non-empty, and Floodlight sees that these two rules are in conflict.
In the case where a rule has wildcarded fields, the union includes the "widest" possible rule.
For example, if the static firewall rule wanted to drop all traffic to \texttt{h8} regardless of destination port then the union would be:
\begin{equation}
(h8) \bigcap (h7:80) (h8:80) \Rightarrow (h7:80) (h8)
\end{equation}


\subsection{Critiques of FortNOX and Implementation Challenges}
\label{subsec:critique}
In designing our implementation of alias reduced rules for rule conflict avoidance, we encountered a number of apparent shortcomings and blind spots in the FortNOX implementation that would still allow a subversive application to insert conflicting rules without detection. Our critiques, and the corresponding challenges are detailed below.

Note that all of our critiques are based solely on the information provided in \cite{Porras:2012:SEK:2342441.2342466}, as the reference implementation of FortNOX was never made public due to concerns about its viability and completeness.\footnote{We confirmed this in communication with FortNOX author Phil Porras.} A reference implementation of SE-Floodlight (secure Floodlight) by the same authors, has been proposed for release in summer 2013. While it is possible that SE-Floodlight will address our concerns, there is currently no implementation available on which to base more specific critiques.

\subsection{Examining Packet Out}
FortNOX focuses only examining and filtering out conflicting \emph{flow rules} from being inserted into switches. However, packet rewriting and manipulation is not limited to flow rules inserted into the switches themselves. Rules can be inserted that, when matched, forward the packet to the controller. This could happen because a new flow has arrived at a switch for which there is not yet a corresponding flow rule, or because an idle or hard timeout means that a previous flow rule has been discarded from the switch. At this point, a subversive application can arbitrarily rewrite a packet \emph{in the controller} in order to subvert rules, before sending it back to the switch to be forwarded. Even if another application in the controller installs a corresponding rule during the same session in the controller, the damage has already been done. 

In order to defend against malicious flow subversion at the controller level, our implementation examines the actions of both attempted flow-table insertions, and of \texttt{PACKET\_OUT} events. That is, we examine outgoing packets to see if they conflict with any of our alias reduced rules in our in-memory mapping of allowed actions. This prevents malicious actions by applications both at the flow-rule level and the controller level.

\subsection{Malicious Tunneling Across Switches}
One of the more substantial issues with the FortNOX approach is that it only verifies that a candidate rule is not in conflict with the current ruleset of a \emph{single} switch's rules. Enforcement at the level of a single switch is suitible only to thwart the simplest attacks, such as the single-rule dynamic tunneling attack outlined in \ref{subsec:arr}. 

However, when a Floodlight application can install rules into multiple switches and/or manipulate packets flowing through multiple switches, comparing new rule insertions with each switch ruleset in isolation is not sufficient to detect conflicts. Consider a simple extension to the dynamic tunneling attack, as follows:
